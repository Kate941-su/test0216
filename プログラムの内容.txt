**********内容説明*************

設問１：故障期間を出力するだけのプログラム。
functions.pyファイルのfile_read関数でコマンドラインから受け取ったテキストファイルのパスからテキストファイルを読み込む。そのデータを1行ずつ読み込んで、
辞書型にしてIPアドレス、応答時間、到着時刻を連想配列にする。また文字型の到着時間を整数型、到着時刻をdatetime型に変換して数値を扱いやすくして一つのリストにまとめる。
check_same_server関数で、文字型のプレフィクスつきIPアドレスを整数型にしてをサブネットと二進数で論理積をとって、ネットワークアドレスを導出する。
次に故障サーバーを特定してその故障サーバーとそれ以降の時刻で同じネットワークアドレスかつ復旧したサーバーを特定する。
ここで故障サーバーが連続してタイムアウトした時、タイムアウトしたときデータをリストに保存しておくことで、同一の故障サーバーが何回も復旧したと認識しないようにする。

設問2:
連続してタイムアウトする回数をN回まで許容できることからNを超えると故障と判定する条件分岐を追加した。
次の設問からもわかるが各サーバーごとに出力する必要があるので、サーバーごとに連想配列データを別々のリストに追加する構成が必要となる。
まずネットワークアドレスは何個あるのかを特定するために、連想配列を一つにまとめたリストから何種類ネットワークアドレスがあるのかを計算する（prefix_count）。
prefix_countの数だけリストを生成し、function,pyファイルのsplit_each_server関数にてネットワークアドレスごとに連想配列を振り分けていく。
わけたリストの中で故障サーバーと通常サーバーを振り分けて、設問1と同じように故障から復旧を判断していく。
（イメージ図をつける）

設問3：
過負荷状態を調べるのがメインなので、直近の到着データm個と過負荷状態と判断する時間tはコマンドラインから入力してもらう。
通常サーバーでの応答時間と、故障サーバーでの応答時間（復帰までの期間）を足してmで平均をとる。その時間がtを超えていたら過負荷状態としてコンソールに出力する。
m入力時にm>(各ログの個数)だった場合、各ログの個数＝mとする。

設問4：
設問2,3の機能を組み合わせて故障時の期間、過負荷状態の出力を組み合わせた。設問２で各サーバーごとに調査できるようプログラムを改変したため、改良点は少ない。

